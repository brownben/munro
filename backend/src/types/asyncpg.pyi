from typing import Any, Iterator, List, Optional, Tuple, TypeVar, Union, overload

_T = TypeVar("_T")

class Record:
    @overload
    def get(self, key: str) -> Optional[Any]: ...
    @overload
    def get(self, key: str, default: _T) -> Union[Any, _T]: ...
    def items(self) -> Iterator[Tuple[str, Any]]: ...
    def keys(self) -> Iterator[str]: ...
    def values(self) -> Iterator[Any]: ...
    @overload
    def __getitem__(self, index: str) -> Any: ...
    @overload
    def __getitem__(self, index: int) -> Any: ...
    @overload
    def __getitem__(self, index: slice) -> Tuple[Any, ...]: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __contains__(self, x: object) -> bool: ...
    def __len__(self) -> int: ...

class ConnectionMeta(type):
    def __instancecheck__(cls, instance: Any) -> Any: ...

class Connection(metaclass=ConnectionMeta):
    def __del__(self) -> None: ...
    async def execute(
        self, query: str, *args: Any, timeout: Optional[float] = ...
    ) -> str: ...
    async def fetch(
        self,
        query: str,
        *args: Any,
        timeout: Optional[float] = ...,
        record_class: Optional[Record] = ...,
    ) -> List[Record]: ...
    async def fetchval(
        self, query: str, *args: Any, column: int = ..., timeout: Optional[float] = ...
    ) -> Optional[Any]: ...
    async def fetchrow(
        self,
        query: str,
        *args: Any,
        timeout: Optional[float] = ...,
        record_class: Optional[Record] = ...,
    ) -> Optional[Record]: ...
    async def close(self, *, timeout: Optional[float] = ...) -> None: ...

async def connect(connection_string: str) -> Connection: ...
