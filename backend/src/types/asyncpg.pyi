from collections.abc import Iterator
from typing import Any, TypeVar, overload

_T = TypeVar("_T")

class Record:
    @overload
    def get(self, key: str) -> Any | None: ...
    @overload
    def get(self, key: str, default: _T) -> Any | _T: ...
    def items(self) -> Iterator[tuple[str, Any]]: ...
    def keys(self) -> Iterator[str]: ...
    def values(self) -> Iterator[Any]: ...
    @overload
    def __getitem__(self, index: str) -> Any: ...
    @overload
    def __getitem__(self, index: int) -> Any: ...
    @overload
    def __getitem__(self, index: slice) -> tuple[Any, ...]: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __contains__(self, x: object) -> bool: ...
    def __len__(self) -> int: ...

class ConnectionMeta(type):
    def __instancecheck__(cls, instance: Any) -> Any: ...

class Connection(metaclass=ConnectionMeta):
    def __del__(self) -> None: ...
    async def execute(
        self, query: str, *args: Any, timeout: float | None = ...
    ) -> str: ...
    async def fetch(
        self,
        query: str,
        *args: Any,
        timeout: float | None = ...,
        record_class: Record | None = ...,
    ) -> list[Record]: ...
    async def fetchval(
        self, query: str, *args: Any, column: int = ..., timeout: float | None = ...
    ) -> Any | None: ...
    async def fetchrow(
        self,
        query: str,
        *args: Any,
        timeout: float | None = ...,
        record_class: Record | None = ...,
    ) -> Record | None: ...
    async def close(self, *, timeout: float | None = ...) -> None: ...

async def connect(connection_string: str) -> Connection: ...
